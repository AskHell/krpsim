use std::str::FromStr;
use std::collections::HashMap;

use crate::ast::{
    Inventory,
    Process,
    Simulation,
    convert
};

grammar;

pub Simulation: Simulation = {
    <i:Associative> <s:Simulation> => {
        let (name, quantity) = i;

        s.add_inventory(name, quantity)
    },
    <p:Process> <s:Simulation> => {
        s.add_process(p)
    },
    <o:Optimize> Comment* => {
        let s = Simulation::default();

        s.optimize(o)
    },
};

Optimize: (Vec<String>, bool) = {
    "optimize" CompleteBy <l: NameList> => {
        let mut vec: Vec<String> = vec![];
        let mut time = false;

        for e in l.into_iter() {
            if e == "time" { time = true; }
            else { vec.push(e) }
        }
        (vec, time)
    }
};

Process: Process = {
    <n:Name> CompleteBy <i:AssociativeList> CompleteBy <o:AssociativeList> CompleteBy <d:Num> => {
        Process::new(n, i, o, d)
    }
};

AssociativeList: Inventory = {
    Open <l:(<Associative> Separate)*> <e:Associative?> Close => {
        let mut vec = l;

        if let Some(e) = e { vec.push(e); }
        convert(vec)
    }
};

NameList: Vec<String> = {
    Open <l:(<Name> Separate)*> <e:Name?> Close => {
        let mut vec = l;

        if let Some(e) = e { vec.push(e); }
        vec
    }
};

Associative: (String, u32) = {
    <a:Name> CompleteBy <b:Num> => {
        (a, b)
    }
};

CompleteBy = Comment* ":";
Separate = Comment* ";";
Open = Comment* "(";
Close = Comment* ")";

Num: u32 = Comment* <r"[0-9]+"> => u32::from_str(<>).unwrap();
Name: String = Comment* <r"[a-zA-Z_]+"> => String::from(<>);

Comment = r"#[^\n]*";
